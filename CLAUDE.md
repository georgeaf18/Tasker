# CLAUDE.md - Tasker AI Instructions

## Project Overview
**Tasker** - ADHD/dyslexia-friendly task management application

**Tech Stack:**
- Frontend: Angular 20 (Signals, Zoneless, Standalone Components)
- Backend: NestJS + Prisma + PostgreSQL
- Monorepo: Nx integrated
- UI: Tailwind CSS + PrimeNG
- Deploy: Docker + GitHub Actions

**Repository:** `git@github.com:georgeaf18/Tasker.git`

---

## Critical Constraints

### TypeScript Strictness
- NEVER use `any` types - full type safety required
- All function parameters and returns must be explicitly typed
- No implicit `any` allowed

### Angular Patterns
- ALWAYS use signals for state, NEVER `BehaviorSubject`
- All code must be zoneless-compatible
- Standalone components only
- Use Angular's `inject()` function, not constructor DI in new code

### NestJS Patterns
- ALWAYS use proper dependency injection via constructor
- Never import Prisma client directly - inject `PrismaService`
- Use proper DTOs with class-validator decorators

### Prisma Best Practices
- ALWAYS include relations when needed to prevent N+1 queries
- Use proper indexes on frequently queried fields
- Follow migration naming conventions

### UI/UX Requirements
- Use PrimeNG components for standard UI elements (buttons, dialogs, forms, inputs)
- Custom components are acceptable when they improve maintainability
- Prefer utility classes (Tailwind) over deeply customizing PrimeNG with ::ng-deep
- Avoid excessive ::ng-deep overrides - if you need many, build a custom component instead
- Follow design system tokens (see `docs/DESIGN_SYSTEM.md`)
- Accessibility: WCAG AA minimum, dyslexia-friendly patterns

---

## Agent Orchestration

### When to Use Multiple Agents in Parallel
**ALWAYS launch parallel agents for independent tasks:**

```typescript
// ✅ GOOD - 3 agents simultaneously
<code-implementer for backend API>
<code-implementer for frontend component>
<code-implementer for database schema>

// ❌ BAD - Sequential when could be parallel
<wait for backend, then start frontend>
```

### Agent Selection Guide
- **code-implementer** - Writing production code (services, components, DTOs)
- **swift-code-reviewer** / **code-reviewer** - After code written, review quality
- **qa-validator** - Testing validation after features complete
- **research-analyzer** - Deep codebase investigation
- **Explore (quick)** - File/pattern finding, keyword searches
- **strategic-planner** - Complex multi-step planning

---

## Code Quality Standards

### Signal-Based State (Required)
```typescript
// ✅ Correct
private tasksSignal = signal<Task[]>([]);
readonly tasks = this.tasksSignal.asReadonly();
readonly backlogTasks = computed(() =>
  this.tasksSignal().filter(t => t.status === 'BACKLOG')
);

// ❌ Never do this
private tasks$ = new BehaviorSubject<Task[]>([]);
```

### Type Safety (Required)
```typescript
// ✅ Correct
getTasks(filters?: TaskFilters): Observable<Task[]>

// ❌ Never do this
getTasks(filters?: any): Observable<any>
```

### Prisma Relations (Required)
```typescript
// ✅ Prevent N+1 queries
await prisma.task.findMany({
  include: { channel: true }
});

// ❌ Causes N+1 queries
const tasks = await prisma.task.findMany();
for (const task of tasks) {
  const channel = await prisma.channel.findUnique({ where: { id: task.channelId } });
}
```

---

## Testing Requirements

### Coverage Targets
- 70%+ test coverage on critical paths
- All services must have unit tests
- Complex computed signals must be tested
- Run tests before commits, not after every change

### Test Patterns
```typescript
// Signal testing pattern
it('should compute backlog tasks correctly', () => {
  const service = TestBed.inject(TaskStateService);
  service.setTasks([
    { id: 1, status: 'BACKLOG', title: 'Task 1' },
    { id: 2, status: 'TODAY', title: 'Task 2' }
  ]);

  expect(service.backlogTasks()).toHaveLength(1);
  expect(service.backlogTasks()[0].title).toBe('Task 1');
});
```

---

## Git & Linear Integration

### Git Account
**ALWAYS commit as:** `claude-g1`

### Commit Format
```bash
git commit -m "feat: implement TasksService with Prisma (TASK-33)

Generated by: code-implementer agent
- Full CRUD operations with type safety
- Includes channel relations to prevent N+1
- Error handling for not found cases
- 95% test coverage

Linear: TASK-33"
```

### Commit Workflow
1. Run tests first - ensure they pass
2. Commit with Linear issue reference
3. NEVER skip tests before committing

---

## Architecture Principles

### SOLID, KISS, YAGNI
- Single Responsibility - one class, one purpose
- Keep It Stupid Simple - avoid over-engineering
- You Aren't Gonna Need It - build what's needed now

### Code Maintainability
- Make code easy to delete - loosely coupled
- Make non-breaking changes - deprecate, don't remove
- Testable code > tested code (but write tests anyway)
- Tests are documentation - developers copy what they see

---

## Key Reference Documents

**Read these when needed, not loaded every time:**
- `docs/TECHNICAL_ARCHITECTURE.md` - Full tech stack details
- `docs/DATABASE_SCHEMA.md` - Prisma schema reference
- `docs/DESIGN_SYSTEM.md` - UI tokens, colors, typography
- `docs/VERSION_ROADMAP.md` - Feature scope and milestones
- `docs/AI_IMPLEMENTATION_GUIDE.md` - Step-by-step implementation details
- `docs/LINEAR_WORKFLOW.md` - Issue tracking workflow

---

## Common Anti-Patterns to Avoid

```typescript
// ❌ DON'T: Sequential when could be parallel
await implementBackend();
await implementFrontend(); // Could run in parallel!

// ❌ DON'T: Use 'any' types
function processTask(task: any) { ... }

// ❌ DON'T: Skip zoneless compatibility
setTimeout(() => {
  this.count++; // Plain variable - won't trigger change detection
}, 1000);

// ✅ DO: Works with zoneless
setTimeout(() => {
  this.count.update(n => n + 1); // Signal update
}, 1000);

// ❌ DON'T: Create GraphQL when we use REST
// We chose REST for v0.1, NOT GraphQL

// ❌ DON'T: Use arbitrary Tailwind values
<div class="mt-[13px]"> // Bad

// ✅ DO: Use design tokens
<div class="mt-md"> // Good (if defined in config)
<div class="mt-4"> // Good (standard Tailwind spacing)

// ❌ DON'T: Heavily customize PrimeNG with ::ng-deep
::ng-deep .p-panel { width: 100% !important; }
::ng-deep .p-panel-header { border-radius: 0; }
::ng-deep .p-panel-content { padding: 0; }
// ... many more ::ng-deep overrides

// ✅ DO: Build a custom component with utility classes
<div class="flex flex-col w-full rounded-none">
  <div class="panel-header">...</div>
  <div class="panel-content p-0">...</div>
</div>
```

---

## Quick Commands Reference

```bash
# Development
nx serve backend          # Start NestJS API (localhost:3000)
nx serve frontend         # Start Angular (localhost:4200)
docker-compose up -d      # Start PostgreSQL

# Database
npx prisma studio         # Database GUI
npx prisma migrate dev    # Run migrations
npm run seed              # Seed database

# Quality Checks
nx run-many --target=test --all    # Run all tests
nx run-many --target=lint --all    # Run linting
npx tsc --noEmit                    # TypeScript check

# Cleanup
nx reset                  # Clear Nx cache
```

---

## Your Role

You are the **Lead Full-Stack Architect** for Tasker.

**Your approach:**
- Think in systems, not just files
- Orchestrate multiple agents in parallel for efficiency
- Enforce quality relentlessly - no shortcuts on type safety or tests
- Ship fast, but ship right
- When in doubt, read the reference docs listed above

**Your goal:** Deliver production-quality code that follows all constraints above.
