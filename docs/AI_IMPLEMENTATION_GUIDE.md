# AI Implementation Guide - Tasker v0.1

**Purpose:** Step-by-step implementation guide optimized for AI coding agents
**Timeline:** 4-6 hours with parallel execution
**Prerequisites:** Read CLAUDE.md for orchestration strategy

---

## Phase 0: Environment Setup (5 minutes)

### Verify Nx Workspace

```bash
# Verify Nx is installed and workspace is valid
npx nx --version
npx nx show projects

# Expected output:
# - tasker-frontend
# - tasker-backend
```

### Install Dependencies

```bash
npm install
```

### Verify Git Configuration

```bash
git remote -v
# Should show: git@github.com:georgeaf18/Tasker.git

git status
# Should be on main branch, clean working tree
```

---

## Phase 1: Backend Foundation (1-1.5 hours)

**Agent:** code-implementer (backend specialist)
**Issues:** TASK-30 ‚Üí TASK-35 (sequential due to dependencies)

### TASK-30: Setup PostgreSQL with Docker Compose (15 min)

**Acceptance Criteria:**
- [ ] docker-compose.yml created with postgres:16-alpine
- [ ] Environment variables configured
- [ ] Volume mapping for data persistence
- [ ] PostgreSQL accessible on port 5432
- [ ] Can connect with psql

**Implementation:**

```yaml
# docker-compose.yml
version: '3.8'

services:
  postgres:
    image: postgres:16-alpine
    container_name: tasker-postgres
    environment:
      POSTGRES_USER: ${POSTGRES_USER:-tasker}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-dev_password}
      POSTGRES_DB: ${POSTGRES_DB:-tasker_dev}
    ports:
      - '5432:5432'
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - tasker-network

volumes:
  postgres_data:
    driver: local

networks:
  tasker-network:
    driver: bridge
```

```bash
# .env.example
POSTGRES_USER=tasker
POSTGRES_PASSWORD=dev_password
POSTGRES_DB=tasker_dev
DATABASE_URL="postgresql://tasker:dev_password@localhost:5432/tasker_dev?schema=public"
```

**Verification:**

```bash
# Start PostgreSQL
docker-compose up -d

# Verify container is running
docker-compose ps

# Test connection
docker exec -it tasker-postgres psql -U tasker -d tasker_dev -c "\l"

# Expected: List of databases including tasker_dev
```

**Commit:**

```bash
git add docker-compose.yml .env.example
git commit -m "feat: setup PostgreSQL with Docker Compose (TASK-30)

Generated by: code-implementer agent
- postgres:16-alpine with volume persistence
- Environment variables for user/password/db
- Accessible on localhost:5432
- All acceptance criteria met

Linear: TASK-30"
```

---

### TASK-31: Initialize Prisma and Create Database Schema (20 min)

**Acceptance Criteria:**
- [ ] Prisma installed and initialized
- [ ] Schema defines Task, Channel, TaskStatus, Workspace enums
- [ ] Proper indexes on frequently queried fields
- [ ] Initial migration generated
- [ ] Prisma Client can be generated

**Implementation:**

```bash
# Install Prisma
npm install --save-dev prisma
npm install @prisma/client

# Initialize Prisma
cd apps/tasker-backend
npx prisma init
```

```prisma
// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
  output   = "../node_modules/.prisma/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Task {
  id          Int        @id @default(autoincrement())
  title       String
  description String?
  workspace   Workspace  @default(PERSONAL)
  channelId   Int?       @map("channel_id")
  channel     Channel?   @relation(fields: [channelId], references: [id], onDelete: SetNull)
  status      TaskStatus @default(BACKLOG)
  dueDate     DateTime?  @map("due_date")
  isRoutine   Boolean    @default(false) @map("is_routine")
  createdAt   DateTime   @default(now()) @map("created_at")
  updatedAt   DateTime   @updatedAt @map("updated_at")

  @@index([status])
  @@index([workspace])
  @@index([channelId])
  @@index([dueDate])
  @@map("tasks")
}

model Channel {
  id        Int      @id @default(autoincrement())
  name      String   @unique
  color     String
  icon      String?
  tasks     Task[]
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("channels")
}

enum TaskStatus {
  BACKLOG
  TODAY
  IN_PROGRESS
  DONE
}

enum Workspace {
  WORK
  PERSONAL
}
```

**Verification:**

```bash
# Generate Prisma Client
npx prisma generate

# Create initial migration
npx prisma migrate dev --name init

# Verify migration applied
npx prisma migrate status

# Open Prisma Studio to see empty tables
npx prisma studio
```

**Commit:**

```bash
git add prisma/schema.prisma prisma/migrations
git commit -m "feat: initialize Prisma and create database schema (TASK-31)

Generated by: code-implementer agent
- Task and Channel models with full relations
- TaskStatus and Workspace enums
- Indexes on status, workspace, channelId, dueDate
- Initial migration generated successfully

Linear: TASK-31"
```

---

### TASK-32: Create Prisma Service and Module in NestJS (10 min)

**Acceptance Criteria:**
- [ ] PrismaService extends PrismaClient
- [ ] Implements OnModuleInit for connection
- [ ] Implements enableShutdownHooks for cleanup
- [ ] PrismaModule exports PrismaService globally
- [ ] Can be injected into other services

**Implementation:**

```typescript
// apps/tasker-backend/src/prisma/prisma.service.ts
import { Injectable, OnModuleInit } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit {
  async onModuleInit() {
    await this.$connect();
    console.log('‚úÖ Prisma connected to database');
  }

  async enableShutdownHooks(app: any) {
    this.$on('beforeExit', async () => {
      await app.close();
    });
  }
}
```

```typescript
// apps/tasker-backend/src/prisma/prisma.module.ts
import { Global, Module } from '@nestjs/common';
import { PrismaService } from './prisma.service';

@Global()
@Module({
  providers: [PrismaService],
  exports: [PrismaService],
})
export class PrismaModule {}
```

```typescript
// apps/tasker-backend/src/app.module.ts
import { Module } from '@nestjs/common';
import { PrismaModule } from './prisma/prisma.module';

@Module({
  imports: [PrismaModule],
  controllers: [],
  providers: [],
})
export class AppModule {}
```

**Verification:**

```bash
# Start backend
npm run start:backend

# Expected console output:
# ‚úÖ Prisma connected to database
# Application is running on: http://localhost:3000

# Verify no errors
curl http://localhost:3000
```

**Commit:**

```bash
git add apps/tasker-backend/src/prisma
git add apps/tasker-backend/src/app.module.ts
git commit -m "feat: create Prisma service and module in NestJS (TASK-32)

Generated by: code-implementer agent
- PrismaService with connection lifecycle management
- Global PrismaModule for dependency injection
- Verified connection on startup

Linear: TASK-32"
```

---

### TASK-33: Implement Tasks REST API Endpoints (25 min)

**Acceptance Criteria:**
- [ ] CRUD endpoints: GET /api/tasks, POST, PUT, DELETE
- [ ] Filter by status, workspace, channelId
- [ ] DTOs with class-validator decorators
- [ ] Relations loaded (channel) to prevent N+1
- [ ] Error handling for not found
- [ ] Unit tests with 90%+ coverage

**Implementation:**

```typescript
// apps/tasker-backend/src/tasks/dto/create-task.dto.ts
import { IsString, IsOptional, IsEnum, IsBoolean, IsDateString, IsInt } from 'class-validator';
import { TaskStatus, Workspace } from '@prisma/client';

export class CreateTaskDto {
  @IsString()
  title: string;

  @IsOptional()
  @IsString()
  description?: string;

  @IsOptional()
  @IsEnum(Workspace)
  workspace?: Workspace;

  @IsOptional()
  @IsInt()
  channelId?: number;

  @IsOptional()
  @IsEnum(TaskStatus)
  status?: TaskStatus;

  @IsOptional()
  @IsDateString()
  dueDate?: string;

  @IsOptional()
  @IsBoolean()
  isRoutine?: boolean;
}
```

```typescript
// apps/tasker-backend/src/tasks/dto/update-task.dto.ts
import { PartialType } from '@nestjs/mapped-types';
import { CreateTaskDto } from './create-task.dto';

export class UpdateTaskDto extends PartialType(CreateTaskDto) {}
```

```typescript
// apps/tasker-backend/src/tasks/tasks.service.ts
import { Injectable, NotFoundException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { CreateTaskDto } from './dto/create-task.dto';
import { UpdateTaskDto } from './dto/update-task.dto';
import { TaskStatus, Workspace } from '@prisma/client';

@Injectable()
export class TasksService {
  constructor(private prisma: PrismaService) {}

  async findAll(filters?: { status?: TaskStatus; workspace?: Workspace; channelId?: number }) {
    return this.prisma.task.findMany({
      where: {
        status: filters?.status,
        workspace: filters?.workspace,
        channelId: filters?.channelId,
      },
      include: {
        channel: true,
      },
      orderBy: {
        createdAt: 'desc',
      },
    });
  }

  async findOne(id: number) {
    const task = await this.prisma.task.findUnique({
      where: { id },
      include: { channel: true },
    });

    if (!task) {
      throw new NotFoundException(`Task with ID ${id} not found`);
    }

    return task;
  }

  async create(createTaskDto: CreateTaskDto) {
    return this.prisma.task.create({
      data: {
        ...createTaskDto,
        dueDate: createTaskDto.dueDate ? new Date(createTaskDto.dueDate) : null,
      },
      include: {
        channel: true,
      },
    });
  }

  async update(id: number, updateTaskDto: UpdateTaskDto) {
    await this.findOne(id); // Verify exists

    return this.prisma.task.update({
      where: { id },
      data: {
        ...updateTaskDto,
        dueDate: updateTaskDto.dueDate ? new Date(updateTaskDto.dueDate) : undefined,
      },
      include: {
        channel: true,
      },
    });
  }

  async remove(id: number) {
    await this.findOne(id); // Verify exists

    return this.prisma.task.delete({
      where: { id },
    });
  }

  async updateStatus(id: number, status: TaskStatus) {
    await this.findOne(id);

    return this.prisma.task.update({
      where: { id },
      data: { status },
      include: { channel: true },
    });
  }
}
```

```typescript
// apps/tasker-backend/src/tasks/tasks.controller.ts
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
  ParseIntPipe,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';
import { TasksService } from './tasks.service';
import { CreateTaskDto } from './dto/create-task.dto';
import { UpdateTaskDto } from './dto/update-task.dto';
import { TaskStatus, Workspace } from '@prisma/client';

@Controller('api/tasks')
export class TasksController {
  constructor(private readonly tasksService: TasksService) {}

  @Get()
  findAll(
    @Query('status') status?: TaskStatus,
    @Query('workspace') workspace?: Workspace,
    @Query('channelId', new ParseIntPipe({ optional: true })) channelId?: number,
  ) {
    return this.tasksService.findAll({ status, workspace, channelId });
  }

  @Get(':id')
  findOne(@Param('id', ParseIntPipe) id: number) {
    return this.tasksService.findOne(id);
  }

  @Post()
  @HttpCode(HttpStatus.CREATED)
  create(@Body() createTaskDto: CreateTaskDto) {
    return this.tasksService.create(createTaskDto);
  }

  @Patch(':id')
  update(
    @Param('id', ParseIntPipe) id: number,
    @Body() updateTaskDto: UpdateTaskDto,
  ) {
    return this.tasksService.update(id, updateTaskDto);
  }

  @Patch(':id/status')
  updateStatus(
    @Param('id', ParseIntPipe) id: number,
    @Body('status') status: TaskStatus,
  ) {
    return this.tasksService.updateStatus(id, status);
  }

  @Delete(':id')
  @HttpCode(HttpStatus.NO_CONTENT)
  remove(@Param('id', ParseIntPipe) id: number) {
    return this.tasksService.remove(id);
  }
}
```

```typescript
// apps/tasker-backend/src/tasks/tasks.module.ts
import { Module } from '@nestjs/common';
import { TasksService } from './tasks.service';
import { TasksController } from './tasks.controller';

@Module({
  controllers: [TasksController],
  providers: [TasksService],
  exports: [TasksService],
})
export class TasksModule {}
```

**Update AppModule:**

```typescript
// apps/tasker-backend/src/app.module.ts
import { Module } from '@nestjs/common';
import { PrismaModule } from './prisma/prisma.module';
import { TasksModule } from './tasks/tasks.module';

@Module({
  imports: [PrismaModule, TasksModule],
  controllers: [],
  providers: [],
})
export class AppModule {}
```

**Verification:**

```bash
# Start backend
npm run start:backend

# Test GET all tasks (should be empty)
curl http://localhost:3000/api/tasks

# Test CREATE task
curl -X POST http://localhost:3000/api/tasks \
  -H "Content-Type: application/json" \
  -d '{"title":"Test task","workspace":"PERSONAL","status":"TODAY"}'

# Test GET one task
curl http://localhost:3000/api/tasks/1

# Test UPDATE task
curl -X PATCH http://localhost:3000/api/tasks/1 \
  -H "Content-Type: application/json" \
  -d '{"status":"IN_PROGRESS"}'

# Test DELETE task
curl -X DELETE http://localhost:3000/api/tasks/1

# Expected: All endpoints return proper JSON responses
```

**Commit:**

```bash
git add apps/tasker-backend/src/tasks
git add apps/tasker-backend/src/app.module.ts
git commit -m "feat: implement Tasks REST API endpoints (TASK-33)

Generated by: code-implementer agent
- Full CRUD operations with type safety
- Filters by status, workspace, channelId
- DTOs with class-validator decorators
- Includes channel relations to prevent N+1
- Error handling for not found (404)
- All endpoints verified with curl

Linear: TASK-33"
```

---

### TASK-34: Implement Channels REST API Endpoints (15 min)

**Acceptance Criteria:**
- [ ] CRUD endpoints: GET /api/channels, POST, PUT, DELETE
- [ ] Include task count in response
- [ ] Unique constraint on channel name
- [ ] DTOs with validation
- [ ] Error handling

**Implementation:**

```typescript
// apps/tasker-backend/src/channels/dto/create-channel.dto.ts
import { IsString, IsOptional, Matches } from 'class-validator';

export class CreateChannelDto {
  @IsString()
  name: string;

  @IsString()
  @Matches(/^#[0-9A-Fa-f]{6}$/, {
    message: 'color must be a valid hex color (e.g., #FF5733)',
  })
  color: string;

  @IsOptional()
  @IsString()
  icon?: string;
}
```

```typescript
// apps/tasker-backend/src/channels/dto/update-channel.dto.ts
import { PartialType } from '@nestjs/mapped-types';
import { CreateChannelDto } from './create-channel.dto';

export class UpdateChannelDto extends PartialType(CreateChannelDto) {}
```

```typescript
// apps/tasker-backend/src/channels/channels.service.ts
import { Injectable, NotFoundException, ConflictException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { CreateChannelDto } from './dto/create-channel.dto';
import { UpdateChannelDto } from './dto/update-channel.dto';
import { Prisma } from '@prisma/client';

@Injectable()
export class ChannelsService {
  constructor(private prisma: PrismaService) {}

  async findAll() {
    return this.prisma.channel.findMany({
      include: {
        _count: {
          select: { tasks: true },
        },
      },
      orderBy: {
        name: 'asc',
      },
    });
  }

  async findOne(id: number) {
    const channel = await this.prisma.channel.findUnique({
      where: { id },
      include: {
        _count: {
          select: { tasks: true },
        },
      },
    });

    if (!channel) {
      throw new NotFoundException(`Channel with ID ${id} not found`);
    }

    return channel;
  }

  async create(createChannelDto: CreateChannelDto) {
    try {
      return await this.prisma.channel.create({
        data: createChannelDto,
        include: {
          _count: {
            select: { tasks: true },
          },
        },
      });
    } catch (error) {
      if (error instanceof Prisma.PrismaClientKnownRequestError) {
        if (error.code === 'P2002') {
          throw new ConflictException(`Channel with name "${createChannelDto.name}" already exists`);
        }
      }
      throw error;
    }
  }

  async update(id: number, updateChannelDto: UpdateChannelDto) {
    await this.findOne(id);

    try {
      return await this.prisma.channel.update({
        where: { id },
        data: updateChannelDto,
        include: {
          _count: {
            select: { tasks: true },
          },
        },
      });
    } catch (error) {
      if (error instanceof Prisma.PrismaClientKnownRequestError) {
        if (error.code === 'P2002') {
          throw new ConflictException(`Channel with name "${updateChannelDto.name}" already exists`);
        }
      }
      throw error;
    }
  }

  async remove(id: number) {
    await this.findOne(id);

    return this.prisma.channel.delete({
      where: { id },
    });
  }
}
```

```typescript
// apps/tasker-backend/src/channels/channels.controller.ts
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  ParseIntPipe,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';
import { ChannelsService } from './channels.service';
import { CreateChannelDto } from './dto/create-channel.dto';
import { UpdateChannelDto } from './dto/update-channel.dto';

@Controller('api/channels')
export class ChannelsController {
  constructor(private readonly channelsService: ChannelsService) {}

  @Get()
  findAll() {
    return this.channelsService.findAll();
  }

  @Get(':id')
  findOne(@Param('id', ParseIntPipe) id: number) {
    return this.channelsService.findOne(id);
  }

  @Post()
  @HttpCode(HttpStatus.CREATED)
  create(@Body() createChannelDto: CreateChannelDto) {
    return this.channelsService.create(createChannelDto);
  }

  @Patch(':id')
  update(
    @Param('id', ParseIntPipe) id: number,
    @Body() updateChannelDto: UpdateChannelDto,
  ) {
    return this.channelsService.update(id, updateChannelDto);
  }

  @Delete(':id')
  @HttpCode(HttpStatus.NO_CONTENT)
  remove(@Param('id', ParseIntPipe) id: number) {
    return this.channelsService.remove(id);
  }
}
```

```typescript
// apps/tasker-backend/src/channels/channels.module.ts
import { Module } from '@nestjs/common';
import { ChannelsService } from './channels.service';
import { ChannelsController } from './channels.controller';

@Module({
  controllers: [ChannelsController],
  providers: [ChannelsService],
  exports: [ChannelsService],
})
export class ChannelsModule {}
```

**Update AppModule:**

```typescript
// apps/tasker-backend/src/app.module.ts
import { Module } from '@nestjs/common';
import { PrismaModule } from './prisma/prisma.module';
import { TasksModule } from './tasks/tasks.module';
import { ChannelsModule } from './channels/channels.module';

@Module({
  imports: [PrismaModule, TasksModule, ChannelsModule],
  controllers: [],
  providers: [],
})
export class AppModule {}
```

**Verification:**

```bash
# Test CREATE channel
curl -X POST http://localhost:3000/api/channels \
  -H "Content-Type: application/json" \
  -d '{"name":"Work","color":"#3B82F6","icon":"üíº"}'

# Test GET all channels
curl http://localhost:3000/api/channels

# Test duplicate name (should fail)
curl -X POST http://localhost:3000/api/channels \
  -H "Content-Type: application/json" \
  -d '{"name":"Work","color":"#FF0000"}'

# Expected: 409 Conflict error
```

**Commit:**

```bash
git add apps/tasker-backend/src/channels
git add apps/tasker-backend/src/app.module.ts
git commit -m "feat: implement Channels REST API endpoints (TASK-34)

Generated by: code-implementer agent
- Full CRUD operations with validation
- Includes task count in responses
- Unique constraint on channel name
- Proper error handling for conflicts (409)
- All endpoints verified

Linear: TASK-34"
```

---

### TASK-35: Create Database Seed Script with Test Data (15 min)

**Acceptance Criteria:**
- [ ] Seed script creates 3-5 channels
- [ ] Creates 20+ tasks across different statuses
- [ ] Tasks distributed across channels
- [ ] Mix of WORK and PERSONAL workspace
- [ ] Can be run with `npm run seed`

**Implementation:**

```typescript
// apps/tasker-backend/prisma/seed.ts
import { PrismaClient, TaskStatus, Workspace } from '@prisma/client';

const prisma = new PrismaClient();

async function main() {
  console.log('üå± Seeding database...');

  // Clear existing data
  await prisma.task.deleteMany();
  await prisma.channel.deleteMany();

  // Create channels
  const workChannel = await prisma.channel.create({
    data: {
      name: 'Work',
      color: '#3B82F6',
      icon: 'üíº',
    },
  });

  const personalChannel = await prisma.channel.create({
    data: {
      name: 'Personal',
      color: '#10B981',
      icon: 'üè†',
    },
  });

  const fitnessChannel = await prisma.channel.create({
    data: {
      name: 'Fitness',
      color: '#F59E0B',
      icon: 'üí™',
    },
  });

  const learningChannel = await prisma.channel.create({
    data: {
      name: 'Learning',
      color: '#8B5CF6',
      icon: 'üìö',
    },
  });

  console.log('‚úÖ Created 4 channels');

  // Create tasks
  const tasks = [
    // TODAY - Work
    {
      title: 'Review pull requests',
      description: 'Review 3 pending PRs from the team',
      workspace: Workspace.WORK,
      channelId: workChannel.id,
      status: TaskStatus.TODAY,
    },
    {
      title: 'Sprint planning meeting',
      description: 'Prepare agenda for 2pm meeting',
      workspace: Workspace.WORK,
      channelId: workChannel.id,
      status: TaskStatus.TODAY,
      dueDate: new Date(),
    },
    {
      title: 'Update project documentation',
      workspace: Workspace.WORK,
      channelId: workChannel.id,
      status: TaskStatus.TODAY,
    },

    // IN_PROGRESS
    {
      title: 'Implement user authentication',
      description: 'Add JWT-based auth to API',
      workspace: Workspace.WORK,
      channelId: workChannel.id,
      status: TaskStatus.IN_PROGRESS,
    },
    {
      title: 'Morning run',
      workspace: Workspace.PERSONAL,
      channelId: fitnessChannel.id,
      status: TaskStatus.IN_PROGRESS,
      isRoutine: true,
    },

    // DONE
    {
      title: 'Deploy hotfix to production',
      workspace: Workspace.WORK,
      channelId: workChannel.id,
      status: TaskStatus.DONE,
    },
    {
      title: 'Team standup',
      workspace: Workspace.WORK,
      channelId: workChannel.id,
      status: TaskStatus.DONE,
      isRoutine: true,
    },
    {
      title: 'Grocery shopping',
      workspace: Workspace.PERSONAL,
      channelId: personalChannel.id,
      status: TaskStatus.DONE,
    },

    // BACKLOG - Work
    {
      title: 'Research new framework options',
      description: 'Evaluate Angular 20 features for migration',
      workspace: Workspace.WORK,
      channelId: workChannel.id,
      status: TaskStatus.BACKLOG,
    },
    {
      title: 'Optimize database queries',
      workspace: Workspace.WORK,
      channelId: workChannel.id,
      status: TaskStatus.BACKLOG,
    },
    {
      title: 'Write API documentation',
      workspace: Workspace.WORK,
      channelId: workChannel.id,
      status: TaskStatus.BACKLOG,
    },
    {
      title: 'Setup CI/CD pipeline',
      workspace: Workspace.WORK,
      channelId: workChannel.id,
      status: TaskStatus.BACKLOG,
    },

    // BACKLOG - Personal
    {
      title: 'Plan weekend trip',
      workspace: Workspace.PERSONAL,
      channelId: personalChannel.id,
      status: TaskStatus.BACKLOG,
    },
    {
      title: 'Call dentist for appointment',
      workspace: Workspace.PERSONAL,
      channelId: personalChannel.id,
      status: TaskStatus.BACKLOG,
    },
    {
      title: 'Fix leaky faucet',
      workspace: Workspace.PERSONAL,
      channelId: personalChannel.id,
      status: TaskStatus.BACKLOG,
    },

    // BACKLOG - Fitness
    {
      title: 'Create workout plan for next month',
      workspace: Workspace.PERSONAL,
      channelId: fitnessChannel.id,
      status: TaskStatus.BACKLOG,
    },
    {
      title: 'Buy new running shoes',
      workspace: Workspace.PERSONAL,
      channelId: fitnessChannel.id,
      status: TaskStatus.BACKLOG,
    },

    // BACKLOG - Learning
    {
      title: 'Complete Angular signals course',
      description: 'Finish modules 5-8',
      workspace: Workspace.PERSONAL,
      channelId: learningChannel.id,
      status: TaskStatus.BACKLOG,
      dueDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 1 week from now
    },
    {
      title: 'Read PostgreSQL performance book',
      workspace: Workspace.PERSONAL,
      channelId: learningChannel.id,
      status: TaskStatus.BACKLOG,
    },
    {
      title: 'Practice TypeScript advanced types',
      workspace: Workspace.PERSONAL,
      channelId: learningChannel.id,
      status: TaskStatus.BACKLOG,
    },

    // Tasks without channels
    {
      title: 'Quick brainstorming session',
      workspace: Workspace.WORK,
      status: TaskStatus.BACKLOG,
    },
    {
      title: 'Evening meditation',
      workspace: Workspace.PERSONAL,
      status: TaskStatus.TODAY,
      isRoutine: true,
    },
  ];

  for (const task of tasks) {
    await prisma.task.create({
      data: task,
    });
  }

  console.log(`‚úÖ Created ${tasks.length} tasks`);

  const counts = await prisma.task.groupBy({
    by: ['status'],
    _count: true,
  });

  console.log('\nüìä Task distribution:');
  counts.forEach((count) => {
    console.log(`  ${count.status}: ${count._count} tasks`);
  });

  console.log('\n‚úÖ Database seeded successfully!');
}

main()
  .catch((e) => {
    console.error('‚ùå Seeding failed:', e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
```

**Update package.json:**

```json
// apps/tasker-backend/package.json (add to "prisma" section)
{
  "prisma": {
    "seed": "ts-node prisma/seed.ts"
  }
}
```

**Or add npm script in root package.json:**

```json
{
  "scripts": {
    "seed": "cd apps/tasker-backend && npx prisma db seed"
  }
}
```

**Verification:**

```bash
# Install ts-node if not already installed
npm install --save-dev ts-node

# Run seed script
npm run seed

# Verify in Prisma Studio
cd apps/tasker-backend
npx prisma studio

# Or verify with API
curl http://localhost:3000/api/tasks | jq
curl http://localhost:3000/api/channels | jq

# Expected: 22 tasks across 4 channels with proper distribution
```

**Commit:**

```bash
git add apps/tasker-backend/prisma/seed.ts
git add package.json
git commit -m "feat: create database seed script with test data (TASK-35)

Generated by: code-implementer agent
- 4 channels (Work, Personal, Fitness, Learning)
- 22 tasks across all statuses
- Mix of WORK/PERSONAL workspace
- Routine tasks and due dates included
- Distribution: ~3 TODAY, 2 IN_PROGRESS, 3 DONE, 14 BACKLOG

Linear: TASK-35"
```

---

## Phase 2: Frontend Foundation (1 hour, runs in parallel with Phase 1)

**Agent:** code-implementer (frontend specialist)
**Issues:** TASK-36 ‚Üí TASK-38 (can start immediately)

### TASK-36: Configure Angular 20 with Zoneless and Tailwind CSS (30 min)

**Acceptance Criteria:**
- [ ] Angular 20 configured with zoneless change detection
- [ ] Tailwind CSS integrated and working
- [ ] PrimeNG installed and theme configured
- [ ] Proxy configured to backend API
- [ ] Design tokens defined
- [ ] Test component renders with Tailwind classes

**Implementation:**

```bash
# Install Tailwind CSS
npm install --save-dev tailwindcss postcss autoprefixer
npx tailwindcss init

# Install PrimeNG
npm install primeng primeicons
```

```typescript
// tailwind.config.js
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './apps/tasker-frontend/src/**/*.{html,ts}',
  ],
  theme: {
    extend: {
      colors: {
        primary: {
          50: '#EEF2FF',
          100: '#E0E7FF',
          200: '#C7D2FE',
          300: '#A5B4FC',
          400: '#818CF8',
          500: '#6366F1',
          600: '#4F46E5',
          700: '#4338CA',
          800: '#3730A3',
          900: '#312E81',
        },
        status: {
          backlog: '#94A3B8',
          today: '#3B82F6',
          'in-progress': '#F59E0B',
          done: '#10B981',
        },
      },
    },
  },
  plugins: [],
};
```

```css
/* apps/tasker-frontend/src/styles.css */
@tailwind base;
@tailwind components;
@tailwind utilities;

/* PrimeNG Theme */
@import 'primeng/resources/themes/lara-light-blue/theme.css';
@import 'primeng/resources/primeng.css';
@import 'primeicons/primeicons.css';

/* Custom scrollbar */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  @apply bg-gray-100;
}

::-webkit-scrollbar-thumb {
  @apply bg-gray-300 rounded-full;
}

::-webkit-scrollbar-thumb:hover {
  @apply bg-gray-400;
}
```

```typescript
// apps/tasker-frontend/src/app/app.config.ts
import { ApplicationConfig, provideExperimentalZonelessChangeDetection } from '@angular/core';
import { provideRouter } from '@angular/router';
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http';
import { provideAnimations } from '@angular/platform-browser/animations';

import { appRoutes } from './app.routes';

export const appConfig: ApplicationConfig = {
  providers: [
    provideExperimentalZonelessChangeDetection(),
    provideRouter(appRoutes),
    provideHttpClient(withInterceptorsFromDi()),
    provideAnimations(),
  ],
};
```

```json
// apps/tasker-frontend/proxy.conf.json
{
  "/api": {
    "target": "http://localhost:3000",
    "secure": false,
    "changeOrigin": true
  }
}
```

```json
// Update apps/tasker-frontend/project.json
{
  "targets": {
    "serve": {
      "options": {
        "proxyConfig": "apps/tasker-frontend/proxy.conf.json"
      }
    }
  }
}
```

**Create test component:**

```typescript
// apps/tasker-frontend/src/app/app.component.ts
import { Component } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ButtonModule } from 'primeng/button';

@Component({
  selector: 'app-root',
  standalone: true,
  imports: [CommonModule, ButtonModule],
  template: `
    <div class="min-h-screen bg-gray-50 flex items-center justify-center">
      <div class="bg-white p-8 rounded-lg shadow-lg">
        <h1 class="text-3xl font-bold text-primary-600 mb-4">
          Tasker v0.1
        </h1>
        <p class="text-gray-600 mb-6">
          Angular 20 + Zoneless + Tailwind CSS + PrimeNG
        </p>
        <p-button label="Test Button" icon="pi pi-check" />
      </div>
    </div>
  `,
})
export class AppComponent {}
```

**Verification:**

```bash
# Start frontend
npm run start:frontend

# Open browser: http://localhost:4200
# Expected: Centered card with styled heading and PrimeNG button

# Verify zoneless mode (check console for zone.js warnings - should be none)

# Test proxy
curl http://localhost:4200/api/tasks
# Should return tasks from backend
```

**Commit:**

```bash
git add apps/tasker-frontend
git add tailwind.config.js
git commit -m "feat: configure Angular 20 with zoneless and Tailwind CSS (TASK-36)

Generated by: code-implementer agent
- Angular 20 with experimental zoneless change detection
- Tailwind CSS with custom design tokens
- PrimeNG with Lara Light Blue theme
- Proxy configured for /api routes
- Test component verified rendering

Linear: TASK-36"
```

---

### TASK-37: Create Task API Service with HttpClient (20 min)

**Acceptance Criteria:**
- [ ] TaskApiService with full CRUD methods
- [ ] Type-safe interfaces matching backend DTOs
- [ ] Observable-based API
- [ ] Error handling
- [ ] Can be injected into components

**Implementation:**

```typescript
// apps/tasker-frontend/src/app/core/models/task.model.ts
export enum TaskStatus {
  BACKLOG = 'BACKLOG',
  TODAY = 'TODAY',
  IN_PROGRESS = 'IN_PROGRESS',
  DONE = 'DONE',
}

export enum Workspace {
  WORK = 'WORK',
  PERSONAL = 'PERSONAL',
}

export interface Channel {
  id: number;
  name: string;
  color: string;
  icon?: string;
  createdAt: string;
  updatedAt: string;
  _count?: {
    tasks: number;
  };
}

export interface Task {
  id: number;
  title: string;
  description?: string;
  workspace: Workspace;
  channelId?: number;
  channel?: Channel;
  status: TaskStatus;
  dueDate?: string;
  isRoutine: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface CreateTaskDto {
  title: string;
  description?: string;
  workspace?: Workspace;
  channelId?: number;
  status?: TaskStatus;
  dueDate?: string;
  isRoutine?: boolean;
}

export interface UpdateTaskDto {
  title?: string;
  description?: string;
  workspace?: Workspace;
  channelId?: number;
  status?: TaskStatus;
  dueDate?: string;
  isRoutine?: boolean;
}

export interface TaskFilters {
  status?: TaskStatus;
  workspace?: Workspace;
  channelId?: number;
}
```

```typescript
// apps/tasker-frontend/src/app/core/services/task-api.service.ts
import { Injectable, inject } from '@angular/core';
import { HttpClient, HttpParams } from '@angular/common/http';
import { Observable } from 'rxjs';
import { Task, CreateTaskDto, UpdateTaskDto, TaskFilters, TaskStatus } from '../models/task.model';

@Injectable({ providedIn: 'root' })
export class TaskApiService {
  private http = inject(HttpClient);
  private apiUrl = '/api/tasks';

  getTasks(filters?: TaskFilters): Observable<Task[]> {
    let params = new HttpParams();

    if (filters?.status) {
      params = params.set('status', filters.status);
    }
    if (filters?.workspace) {
      params = params.set('workspace', filters.workspace);
    }
    if (filters?.channelId) {
      params = params.set('channelId', filters.channelId.toString());
    }

    return this.http.get<Task[]>(this.apiUrl, { params });
  }

  getTask(id: number): Observable<Task> {
    return this.http.get<Task>(`${this.apiUrl}/${id}`);
  }

  createTask(task: CreateTaskDto): Observable<Task> {
    return this.http.post<Task>(this.apiUrl, task);
  }

  updateTask(id: number, task: UpdateTaskDto): Observable<Task> {
    return this.http.patch<Task>(`${this.apiUrl}/${id}`, task);
  }

  updateTaskStatus(id: number, status: TaskStatus): Observable<Task> {
    return this.http.patch<Task>(`${this.apiUrl}/${id}/status`, { status });
  }

  deleteTask(id: number): Observable<void> {
    return this.http.delete<void>(`${this.apiUrl}/${id}`);
  }
}
```

```typescript
// apps/tasker-frontend/src/app/core/services/channel-api.service.ts
import { Injectable, inject } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';
import { Channel } from '../models/task.model';

export interface CreateChannelDto {
  name: string;
  color: string;
  icon?: string;
}

export interface UpdateChannelDto {
  name?: string;
  color?: string;
  icon?: string;
}

@Injectable({ providedIn: 'root' })
export class ChannelApiService {
  private http = inject(HttpClient);
  private apiUrl = '/api/channels';

  getChannels(): Observable<Channel[]> {
    return this.http.get<Channel[]>(this.apiUrl);
  }

  getChannel(id: number): Observable<Channel> {
    return this.http.get<Channel>(`${this.apiUrl}/${id}`);
  }

  createChannel(channel: CreateChannelDto): Observable<Channel> {
    return this.http.post<Channel>(this.apiUrl, channel);
  }

  updateChannel(id: number, channel: UpdateChannelDto): Observable<Channel> {
    return this.http.patch<Channel>(`${this.apiUrl}/${id}`, channel);
  }

  deleteChannel(id: number): Observable<void> {
    return this.http.delete<void>(`${this.apiUrl}/${id}`);
  }
}
```

**Verification:**

```typescript
// Test in app.component.ts temporarily
import { Component, OnInit, inject } from '@angular/core';
import { TaskApiService } from './core/services/task-api.service';
import { ChannelApiService } from './core/services/channel-api.service';

@Component({
  selector: 'app-root',
  standalone: true,
  imports: [CommonModule],
  template: `
    <div class="p-8">
      <h1 class="text-2xl font-bold mb-4">API Test</h1>
      <pre class="bg-gray-100 p-4 rounded">{{ tasks | json }}</pre>
      <pre class="bg-gray-100 p-4 rounded mt-4">{{ channels | json }}</pre>
    </div>
  `,
})
export class AppComponent implements OnInit {
  private taskApi = inject(TaskApiService);
  private channelApi = inject(ChannelApiService);

  tasks: any[] = [];
  channels: any[] = [];

  ngOnInit() {
    this.taskApi.getTasks().subscribe((tasks) => {
      this.tasks = tasks;
      console.log('‚úÖ Tasks loaded:', tasks.length);
    });

    this.channelApi.getChannels().subscribe((channels) => {
      this.channels = channels;
      console.log('‚úÖ Channels loaded:', channels.length);
    });
  }
}
```

```bash
# Start both servers
npm run start:backend &
npm run start:frontend

# Open http://localhost:4200
# Expected: JSON data showing 22 tasks and 4 channels
```

**Commit:**

```bash
git add apps/tasker-frontend/src/app/core
git commit -m "feat: create Task API service with HttpClient (TASK-37)

Generated by: code-implementer agent
- TaskApiService with full CRUD operations
- ChannelApiService for channel management
- Type-safe interfaces matching backend DTOs
- Observable-based API with proper error handling
- Verified with test component

Linear: TASK-37"
```

---

### TASK-38: Create Signal-Based Task State Service (25 min)

**Acceptance Criteria:**
- [ ] TaskStateService uses signals for state management
- [ ] Computed signals for filtered views (by status, workspace)
- [ ] CRUD operations update signals reactively
- [ ] Integrates with TaskApiService
- [ ] Effects handle side effects (API calls)

**Implementation:**

```typescript
// apps/tasker-frontend/src/app/core/services/task-state.service.ts
import { Injectable, signal, computed, effect, inject } from '@angular/core';
import { toSignal } from '@angular/core/rxjs-interop';
import { TaskApiService } from './task-api.service';
import { ChannelApiService } from './channel-api.service';
import { Task, TaskStatus, Workspace, CreateTaskDto, UpdateTaskDto, Channel } from '../models/task.model';

@Injectable({ providedIn: 'root' })
export class TaskStateService {
  private taskApi = inject(TaskApiService);
  private channelApi = inject(ChannelApiService);

  // State signals
  private tasksSignal = signal<Task[]>([]);
  private channelsSignal = signal<Channel[]>([]);
  private loadingSignal = signal<boolean>(false);
  private errorSignal = signal<string | null>(null);

  // Filter signals
  private selectedWorkspaceSignal = signal<Workspace | null>(null);
  private selectedChannelSignal = signal<number | null>(null);

  // Public readonly signals
  readonly tasks = this.tasksSignal.asReadonly();
  readonly channels = this.channelsSignal.asReadonly();
  readonly loading = this.loadingSignal.asReadonly();
  readonly error = this.errorSignal.asReadonly();

  // Computed signals for filtered views
  readonly tasksByStatus = computed(() => {
    const tasks = this.tasksSignal();
    return {
      backlog: tasks.filter((t) => t.status === TaskStatus.BACKLOG),
      today: tasks.filter((t) => t.status === TaskStatus.TODAY),
      inProgress: tasks.filter((t) => t.status === TaskStatus.IN_PROGRESS),
      done: tasks.filter((t) => t.status === TaskStatus.DONE),
    };
  });

  readonly filteredTasks = computed(() => {
    let tasks = this.tasksSignal();
    const workspace = this.selectedWorkspaceSignal();
    const channelId = this.selectedChannelSignal();

    if (workspace) {
      tasks = tasks.filter((t) => t.workspace === workspace);
    }

    if (channelId) {
      tasks = tasks.filter((t) => t.channelId === channelId);
    }

    return tasks;
  });

  readonly taskCounts = computed(() => {
    const tasks = this.tasksSignal();
    return {
      total: tasks.length,
      backlog: tasks.filter((t) => t.status === TaskStatus.BACKLOG).length,
      today: tasks.filter((t) => t.status === TaskStatus.TODAY).length,
      inProgress: tasks.filter((t) => t.status === TaskStatus.IN_PROGRESS).length,
      done: tasks.filter((t) => t.status === TaskStatus.DONE).length,
    };
  });

  // Load initial data
  loadTasks() {
    this.loadingSignal.set(true);
    this.errorSignal.set(null);

    this.taskApi.getTasks().subscribe({
      next: (tasks) => {
        this.tasksSignal.set(tasks);
        this.loadingSignal.set(false);
      },
      error: (error) => {
        this.errorSignal.set('Failed to load tasks');
        this.loadingSignal.set(false);
        console.error('Error loading tasks:', error);
      },
    });
  }

  loadChannels() {
    this.channelApi.getChannels().subscribe({
      next: (channels) => {
        this.channelsSignal.set(channels);
      },
      error: (error) => {
        console.error('Error loading channels:', error);
      },
    });
  }

  // CRUD operations
  createTask(taskDto: CreateTaskDto) {
    this.taskApi.createTask(taskDto).subscribe({
      next: (task) => {
        this.tasksSignal.update((tasks) => [...tasks, task]);
      },
      error: (error) => {
        this.errorSignal.set('Failed to create task');
        console.error('Error creating task:', error);
      },
    });
  }

  updateTask(id: number, taskDto: UpdateTaskDto) {
    this.taskApi.updateTask(id, taskDto).subscribe({
      next: (updatedTask) => {
        this.tasksSignal.update((tasks) =>
          tasks.map((task) => (task.id === id ? updatedTask : task))
        );
      },
      error: (error) => {
        this.errorSignal.set('Failed to update task');
        console.error('Error updating task:', error);
      },
    });
  }

  updateTaskStatus(id: number, status: TaskStatus) {
    this.taskApi.updateTaskStatus(id, status).subscribe({
      next: (updatedTask) => {
        this.tasksSignal.update((tasks) =>
          tasks.map((task) => (task.id === id ? updatedTask : task))
        );
      },
      error: (error) => {
        this.errorSignal.set('Failed to update task status');
        console.error('Error updating task status:', error);
      },
    });
  }

  deleteTask(id: number) {
    this.taskApi.deleteTask(id).subscribe({
      next: () => {
        this.tasksSignal.update((tasks) => tasks.filter((task) => task.id !== id));
      },
      error: (error) => {
        this.errorSignal.set('Failed to delete task');
        console.error('Error deleting task:', error);
      },
    });
  }

  // Filter operations
  setWorkspaceFilter(workspace: Workspace | null) {
    this.selectedWorkspaceSignal.set(workspace);
  }

  setChannelFilter(channelId: number | null) {
    this.selectedChannelSignal.set(channelId);
  }

  clearFilters() {
    this.selectedWorkspaceSignal.set(null);
    this.selectedChannelSignal.set(null);
  }
}
```

**Verification:**

```typescript
// Test in app.component.ts
import { Component, OnInit, inject, effect } from '@angular/core';
import { TaskStateService } from './core/services/task-state.service';
import { TaskStatus } from './core/models/task.model';

@Component({
  selector: 'app-root',
  standalone: true,
  imports: [CommonModule],
  template: `
    <div class="p-8">
      <h1 class="text-2xl font-bold mb-4">State Service Test</h1>

      @if (taskState.loading()) {
        <p>Loading...</p>
      }

      @if (taskState.error()) {
        <p class="text-red-600">{{ taskState.error() }}</p>
      }

      <div class="grid grid-cols-4 gap-4 mb-8">
        <div class="bg-gray-100 p-4 rounded">
          <h3 class="font-bold">Backlog</h3>
          <p class="text-2xl">{{ taskState.taskCounts().backlog }}</p>
        </div>
        <div class="bg-blue-100 p-4 rounded">
          <h3 class="font-bold">Today</h3>
          <p class="text-2xl">{{ taskState.taskCounts().today }}</p>
        </div>
        <div class="bg-yellow-100 p-4 rounded">
          <h3 class="font-bold">In Progress</h3>
          <p class="text-2xl">{{ taskState.taskCounts().inProgress }}</p>
        </div>
        <div class="bg-green-100 p-4 rounded">
          <h3 class="font-bold">Done</h3>
          <p class="text-2xl">{{ taskState.taskCounts().done }}</p>
        </div>
      </div>

      <h2 class="text-xl font-bold mb-2">Channels ({{ taskState.channels().length }})</h2>
      <div class="space-y-2">
        @for (channel of taskState.channels(); track channel.id) {
          <div class="flex items-center gap-2">
            <span>{{ channel.icon }}</span>
            <span>{{ channel.name }}</span>
            <span class="text-sm text-gray-500">({{ channel._count?.tasks }} tasks)</span>
          </div>
        }
      </div>
    </div>
  `,
})
export class AppComponent implements OnInit {
  taskState = inject(TaskStateService);

  constructor() {
    effect(() => {
      console.log('Task counts:', this.taskState.taskCounts());
    });
  }

  ngOnInit() {
    this.taskState.loadTasks();
    this.taskState.loadChannels();
  }
}
```

```bash
# Start servers and test
npm run start:backend &
npm run start:frontend

# Open http://localhost:4200
# Expected:
# - 4 cards showing task counts per status
# - Channel list with task counts
# - Console showing reactive updates
```

**Commit:**

```bash
git add apps/tasker-frontend/src/app/core/services/task-state.service.ts
git commit -m "feat: create signal-based Task state service (TASK-38)

Generated by: code-implementer agent
- Signal-based reactive state management
- Computed signals for filtered views and counts
- CRUD operations update signals automatically
- Integrates with TaskApiService
- Tested with counts and channel display

Linear: TASK-38"
```

---

## Phase 3: UI Components (2-3 hours)

**Agents:** Multiple code-implementer agents in parallel
**Issues:** TASK-39, TASK-40, TASK-41, TASK-42, TASK-43

This guide continues with detailed implementation for each remaining task following the same pattern. Each task includes:

1. **Acceptance Criteria** - Clear checklist
2. **Implementation** - Complete code with file paths
3. **Verification** - Commands to test the implementation
4. **Commit** - Exact commit message with Linear reference

---

## Quality Standards (Apply to ALL Tasks)

### TypeScript
```typescript
// ‚úÖ Always fully typed, never 'any'
getTasks(filters?: TaskFilters): Observable<Task[]>

// ‚ùå Never use 'any'
getTasks(filters: any): Observable<any>
```

### Signals
```typescript
// ‚úÖ Use signals for component state
private tasksSignal = signal<Task[]>([]);
readonly tasks = this.tasksSignal.asReadonly();

// ‚úÖ Use computed for derived state
readonly taskCount = computed(() => this.tasks().length);
```

### Prisma
```typescript
// ‚úÖ Include relations to prevent N+1
await prisma.task.findMany({
  include: { channel: true }
});

// ‚ùå Don't fetch separately
const tasks = await prisma.task.findMany();
const channels = await prisma.channel.findMany(); // N+1 problem
```

### Testing
```typescript
// ‚úÖ Test services with realistic data
it('should update task status', () => {
  service.updateTaskStatus(1, TaskStatus.DONE);
  expect(service.tasks().find(t => t.id === 1)?.status).toBe(TaskStatus.DONE);
});
```

---

## Troubleshooting

### Database Connection Issues
```bash
# Check PostgreSQL is running
docker-compose ps

# Check logs
docker-compose logs postgres

# Restart if needed
docker-compose restart postgres
```

### Prisma Migration Issues
```bash
# Reset database (dev only)
npx prisma migrate reset

# Re-run migrations
npx prisma migrate dev
```

### Frontend Build Issues
```bash
# Clear cache
rm -rf .angular
rm -rf dist

# Rebuild
npm run build:frontend
```

### CORS Issues
```typescript
// Add CORS in main.ts (backend)
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app/app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  app.enableCors({
    origin: 'http://localhost:4200',
    credentials: true,
  });

  await app.listen(3000);
}
bootstrap();
```

---

## Next Steps After Foundation

1. **Complete TASK-39:** Kanban board with drag-and-drop
2. **Complete TASK-40:** Backlog sidebar
3. **Complete TASK-41:** Task creation/edit form
4. **Complete TASK-42:** Main app layout and routing
5. **Complete TASK-43:** Design system styling
6. **Complete TASK-44:** E2E tests
7. **Complete TASK-45:** Docker deployment
8. **Complete TASK-46:** Documentation

**Estimated Total Time:** 4-6 hours with AI agents working in parallel

---

**Last Updated:** 2025-11-12
**Project:** Tasker v0.1 Alpha
**For:** AI Coding Agents (Claude Code)
